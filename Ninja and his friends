#include <iostream>
using namespace std;

// Ninja and his friends --- 3D(DP)

/*
Problem Statement
Ninja has a ‘GRID’ of size R × C. Each cell of the grid 
contains some chocolates. Ninja has two friends Alice and
Bob, and he wants to collect as many chocolates as possible 
with the help of his friends.

Initially, Alice is in the top-left position i.e. (0, 0), 
and Bob is in the top-right place i.e. (0, C - 1) in the grid. 
Each of them can move from their current cell to the cells 
just below them. When anyone passes from any cell, he will 
pick all chocolates in it, and then the number of chocolates 
in that cell will become zero. If both stay in the same cell, 
only one of them will pick the chocolates in it.

If Alice or Bob is at (i, j) then they can move to (i + 1, j), 
(i + 1, j - 1) or (i + 1, j + 1). They will always stay inside 
the ‘GRID’.

Your task is to find the maximum number of chocolates Ninja 
can collect with the help of his friends by following the 
above rules.
*/

class Solution {
    /*
    int func1(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid){
        if (j1<0 || j1>=c || j2<0 || j2>=c) return -1e8;
        if (i==r-1){
            if (j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        int maxi=-1e8;
        for(int dj1=-1;dj1<=1;dj1++){
            for(int dj2=-1;dj2<=1;dj2++){
                int value = 0;
                if (j1 == j2) value = grid[i][j1];
                else value = grid[i][j1] + grid[i][j2];
                value += func1(i + 1, j1 + dj1, j2 + dj2, r, c, grid);
                maxi = max(maxi, value);
            }
        }
        return maxi;
    }
    */
    /*
    int func2(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp){
        if (j1<0 || j1>=c || j2<0 || j2>=c) return -1e8;
        if (dp[i][j1][j2]!=-1) return dp[i][j1][j2];
        if (i==r-1){
            if (j1==j2) return grid[i][j1];
            else return grid[i][j1]+grid[i][j2];
        }
        int maxi=-1e8;
        for(int dj1=-1;dj1<=1;dj1++){
            for(int dj2=-1;dj2<=1;dj2++){
                int value = 0;
                if (j1 == j2) value = grid[i][j1];
                else value = grid[i][j1] + grid[i][j2];
                value += func2(i + 1, j1 + dj1, j2 + dj2, r, c, grid, dp);
                maxi = max(maxi, value);
            }
        }
        return dp[i][j1][j2]=maxi;
    }
    */
public:
    int maximumChocolate(int r, int c, vector<vector<int>>& grid) {
        /*
        // 1. recursion
        // TC : O(3^r * 3^r)~exp
        // SC : O(r)<-stack space
        return func1(0, 0, c-1, r, c, grid);
        */
        /*
        // 2. memoization
        // TC : O(r*c*c)*9
        // SC : dp-->O(r*c*c)+O(r)<--stack space
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));
        return func2(0, 0, c-1, r, c, grid, dp);
        */
        /*
        // 3. tabulation
        // TC : O(r*c*c)*9
        // SC : dp-->O(r*c*c)
        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, 0)));
        for(int j1=0;j1<c;j1++){
            for(int j2=0;j2<c;j2++){
                if (j1==j2) dp[r-1][j1][j2]=grid[r-1][j1];
                else dp[r-1][j1][j2]=grid[r-1][j1]+grid[r-1][j2];
            }
        }
        for(int i=r-2;i>=0;i--){
            for(int j1=0;j1<c;j1++){
                for(int j2=0;j2<c;j2++){
                    int maxi=-1e8;
                    for(int dj1=-1;dj1<=1;dj1++){
                        for(int dj2=-1;dj2<=1;dj2++){
                            int value = 0;
                            if (j1 == j2) value = grid[i][j1];
                            else value = grid[i][j1] + grid[i][j2];
                            if (j1+dj1>=0 && j1+dj1<c && j2+dj2>=0 && j2+dj2<c){
                                value+=dp[i+1][j1+dj1][j2+dj2];
                            }
                            else value+=-1e8;
                            maxi = max(maxi, value);
                        }
                    }           
                    dp[i][j1][j2]=maxi;
                }
            }
        }
        return dp[0][0][c-1];
        */
        // 3. space optimized
        // TC : O(r*c*c)*9
        // SC : dp-->O(c*c)
        vector<vector<int>> front(c, vector<int>(c, 0));
        vector<vector<int>> curr(c, vector<int>(c, 0));
        for (int j1 = 0; j1 < c; j1++) {
            for (int j2 = 0; j2 < c; j2++) {
                if (j1 == j2) front[j1][j2] = grid[r - 1][j1];
                else front[j1][j2] = grid[r - 1][j1] + grid[r - 1][j2];
            }
        }
        for (int i = r - 2; i >= 0; i--) {
            for (int j1 = 0; j1 < c; j1++) {
                for (int j2 = 0; j2 < c; j2++) {
                    int maxi = -1e8;
                    for (int dj1 = -1; dj1 <= 1; dj1++) {
                        for (int dj2 = -1; dj2 <= 1; dj2++) {
                            if (j1 + dj1 >= 0 && j1 + dj1 < c && j2 + dj2 >= 0 && j2 + dj2 < c) {
                                int value = (j1 == j2 ? grid[i][j1] : grid[i][j1] + grid[i][j2]);
                                value += front[j1 + dj1][j2 + dj2];
                                maxi = max(maxi, value);
                            }
                        }
                    }
                    curr[j1][j2] = maxi;
                }
            }
            front = curr; 
        }
        return front[0][c-1];
    }
};
